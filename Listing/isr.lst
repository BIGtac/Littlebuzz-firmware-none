C51 COMPILER V9.00   ISR                                                                   07/23/2016 15:35:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\Output\isr.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE User\isr.c LARGE BROWSE INCDIR(.\Common\inc;.\Driver\inc;.\BSP;.\Startup;.\
                    -User) DEBUG OBJECTEXTEND PRINT(.\Listing\isr.lst) OBJECT(.\Output\isr.obj)

line level    source

   1          /********************************************************************
   2          作者：Songyimiao
   3          建立日期: 20151129
   4          版本：V2.0
   5          喵呜实验室版权所有
   6          /********************************************************************/
   7          #include "includes.h"
   8          
   9          
  10          
  11          /***************************************************************
  12          ** 作　  者: Songyibiao
  13          ** 官    网：http://www.miaowlabs.com
  14          ** 淘    宝：http://miaowlabs.taobao.com
  15          ** 日　  期: 2015年11月29日
  16          ** 函数名称: Timer1_Update
  17          ** 功能描述: 100hz中断服务函数            
  18          ** 输　  入:   
  19          ** 输　  出:   
  20          ** 备    注: 
  21          ********************喵呜实验室版权所有**************************
  22          ***************************************************************/
  23          void Timer1_Update(void) interrupt  3           //100hz
  24          {  
  25   1              i++;
  26   1      
  27   1              g_Throttle=(float)(255 - RxBuf[1]);     //油门  RxBuf[1]:0-255
  28   1      
  29   1              if(g_Throttle>80)//如果油门大于80 即已起飞
  30   1              {
  31   2                      if(RxBuf[0]==g_LastCountRunAway)//如果RxBuf[0]的数据没有收到 即矢联
  32   2                      {
  33   3                              g_CountRunAway++;  //状态标识+1
  34   3                              if(g_CountRunAway>128){g_CountRunAway=128;}  //状态标识大于128即1秒没有收到数据，失控保护
  35   3                      }
  36   2                      else{g_CountRunAway=0;}
  37   2              }
  38   1              else{g_CountRunAway=0;} //收到信号退出失控保护
  39   1              if(g_CountRunAway==128){g_Throttle=101;RxBuf[1]=128;RxBuf[2]=128;} //触发失控保护 油门为1半少一点，缓慢下
             -降，俯仰横滚方向舵归中
  40   1      
  41   1              
  42   1              g_LastCountRunAway=RxBuf[0];
  43   1              SampleInputVoltage();
  44   1      
  45   1              Angle_ax=(float)g_iAccel_X_Axis/8192;  //加速度处理
  46   1              Angle_ay=(float)g_iAccel_Y_Axis/8192;  //转换关系8192LSB/g
  47   1              Angle_az=(float)g_iAccel_Z_Axis/8192;  //加速度量程 +-4g/S
  48   1              Angle_gx -= g_fGyroXOffset;
  49   1              Angle_gy -= g_fGyroYOffset;
  50   1              Angle_gz -= g_fGyroZOffset;
  51   1              Angle_gx=(float)g_iGyro_X_Axis/65.5;   //陀螺仪处理
  52   1              Angle_gy=(float)g_iGyro_Y_Axis/65.5;   //陀螺仪量程 
  53   1              Angle_gz=(float)g_iGyro_Z_Axis/65.5;   //转换关系65.5LSB/度
C51 COMPILER V9.00   ISR                                                                   07/23/2016 15:35:45 PAGE 2   

  54   1              
  55   1      //***********************************四元数***********************************
  56   1              IMUupdate(Angle_gx*0.0174533,Angle_gy*0.0174533,Angle_gz*0.0174533,Angle_ax*0.0174533,Angle_ay*0.0174533,
             -Angle_az*0.0174533);
  57   1              //*0.0174533为PI/180 目的是将角度转弧度
  58   1      
  59   1              if(123<TxBuf[2]<133)
  60   1              {
  61   2              TxBuf[2]=128;
  62   2              }
  63   1              if(123<TxBuf[3]<133)
  64   1              {
  65   2              TxBuf[3]=128;
  66   2              }
  67   1              if(113<TxBuf[4]<143)
  68   1              {
  69   2              TxBuf[4]=128;
  70   2              }
  71   1      
  72   1              AttitudeControl();
  73   1                                                                
  74   1              if(g_Throttle>=10)
  75   1              {PWM(PWM3,PWM2,PWM1,PWM4);}      //入口2345-   PWM3/PWM2/PWM1/PWM4
  76   1              else 
  77   1              {PWM(1000,1000,1000,1000);}       
  78   1              
  79   1              //UART1SendByte(0x78)   ;                                                         
  80   1      #if 0//DEBUG_UART  //调试启用 预编译命令
              
              //      OutData[0] = Angle_gx;
              //      OutData[1] = Angle_gy;
              //      OutData[2] = pitch;//对应Angle_gy
              //      OutData[3] = roll; //对应Angle_gx 
                      OutData[0] = g_fOffsetx;
                      OutData[1] = g_fOffsety;        
                      OutData[2] = g_fPower;
                      OutData[3] = yaw; 
                      OutPut_Data();          
                                        
              #endif                  
  93   1              
  94   1                      g_ucLEDCount++;
  95   1                      if(g_ucLEDCount >=125) //LED1灯1秒交替闪烁
  96   1                      {
  97   2                              g_ucLEDCount=0;
  98   2                              LED_GREEN = ~LED_GREEN;
  99   2                      }
 100   1                               
 101   1      }
 102          
 103          
 104                                           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    990    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.00   ISR                                                                   07/23/2016 15:35:45 PAGE 3   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
